public enum PlantState {SEED, SPROUT, MATURE, FLOWERING}
/**
  this class represent food for Herbivore. Plant seed is generated by herbivore poop and flowering Plant
**/
class Plant extends WorldObject{
  
//config attributes
  //flowering state attributes
  final static int floweringDelay = 4000;
  final static int floweringStateEnergy = 200;
  final static int flowerSeedRadius = 75;
  final static color floweringColor = #ba390e;
  //mature state attributes
  final static int matureStateEnergy = 100;
  final static color matureColor = #c4c431;
  final static int matureFoodAmount = 3;
  //sprout state attributes
  final static color sproutColor = #458B00;
  final static int sproutFoodAmount = 1;
  //plant attributes
  static final int defaultWidth = 5;
  static final int defaultHeight = -30;
  static final float energySizeMultiplicator = 0.005;//used to calcul sizeModifier
  static final float energyRootMultiplicator = 0.50;
  static final int defaultEnergy = 20; 
  final static int eatDelay = 200;
  
//attributes
  ArrayList<Fertilizer> fertilizers;
  Fertilizer fertilizer;
  int energy;
  float rootRadius;
  PlantState state;
  Delay floweringTimer = new Delay(floweringDelay);
  Delay eatTimer = new Delay(eatDelay);
  color strokeColor;
  
//constructors 
  Plant(float x, float y ,World world){
  //WorldObject attributes
    this.world = world;
    location = new PVector (x , y );
    size = new PVector();
    
  //Plant attributes
    state = PlantState.SEED;
    fertilizers = world.fertilizers;
    energy = defaultEnergy;
    sizeUpdate();
    rootUpdate();
  }
 
//inherited methods
  void update(long deltaTime){

    switch(state){
      case SEED:
        seedUpdate();
        break;
      case SPROUT:
        sproutUpdate(deltaTime);
        break;
      case MATURE:
        matureUpdate(deltaTime);
        break;
      case FLOWERING:
        floweringUpdate(deltaTime);
        break;
    }
    sizeUpdate();
    setColor();
    rootUpdate();
    if(state != PlantState.SEED){
      if(energy <= 0  )
        world.removePlant(this);
      else if(energy < matureStateEnergy)
        this.state = PlantState.SPROUT;
      else if(energy < floweringStateEnergy)
        this.state = PlantState.MATURE;
      else 
        this.state = PlantState.FLOWERING;
    }
  }
  
  void render(){
    pushMatrix();
    stroke(strokeColor);
    strokeWeight(size.x);
    line(location.x, location.y, location.x+size.x ,location.y+size.y);
    
    popMatrix();
  }
  
//state methods
  void seedUpdate(){
    
    if(findFertilizer())
      this.state = PlantState.SPROUT;
  }
 
  void sproutUpdate(long deltaTime){
   
    if(fertilizer != null){
      eatTimer.update(deltaTime);
      if(eatTimer.expired()){
        int newEnergy = fertilizer.deplete(sproutFoodAmount);
        energy += newEnergy;
        if(newEnergy == 0)
          this.fertilizer = null;
      }
    }else
      findFertilizer();
  }
  
  void matureUpdate(long deltaTime){
    
    if(fertilizer != null){
      eatTimer.update(deltaTime);
      if(eatTimer.expired()){
        int newEnergy = fertilizer.deplete(matureFoodAmount);
        energy += newEnergy;
        if(newEnergy == 0)
          this.fertilizer = null;
      }
    }else
      findFertilizer();
  }

  void floweringUpdate(long deltaTime){
    
    floweringTimer.update(deltaTime);
    if(floweringTimer.expired()){
      int nbFlowerSeed = ((floweringStateEnergy - matureStateEnergy) / defaultEnergy); 
      for(int i = 0 ; i < nbFlowerSeed ; i++){
        PVector newLocation = new PVector(this.location.x+random(-flowerSeedRadius,flowerSeedRadius),this.location.y + random(-flowerSeedRadius,flowerSeedRadius));
        Plant newPlant = new Plant(newLocation.x,newLocation.y,world);
        this.energy -= defaultEnergy;
        world.addPlant(newPlant);
      }
      this.state = PlantState.MATURE;
    }  
  }
  
//methods
  int deplete(int amount){

    if(energy >= amount){
      energy -= amount;
      return amount;
    }
    else if(energy > 0){
      int value = energy;
      energy = 0;
      return value;
    }
    return 0;
  }
  
  void sizeUpdate(){
    
    if(state == PlantState.SEED)
      size.set(1,1);
    else{
      float sizeModifier = (float) energySizeMultiplicator * energy;
      size.set(defaultWidth*sizeModifier,defaultHeight*sizeModifier);
    } 
  }
  
  void rootUpdate(){
    rootRadius = energyRootMultiplicator * energy;
  }
  
  void setColor(){
    switch(state){
      case SEED:
        strokeColor = sproutColor;
        break;
      case SPROUT:
        strokeColor = sproutColor;
        break;
      case MATURE:
        strokeColor = matureColor;
        break;
      case FLOWERING:
        strokeColor = floweringColor;
        break;
    }
  }
  
  Boolean findFertilizer(){
    for(Fertilizer f:fertilizers){
      if(PVector.dist(f.location,this.location) < (f.fertilizingRayon + rootRadius)){
        fertilizer = f;
        return true;
      }
    }
    return false;
  }
}